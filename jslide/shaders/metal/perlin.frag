/**
An implementation of tileable 3D Perlin-Worley noise for modeling volumetric clouds
inspired from the chapter Real-Time Volumetric Cloudscapes by Andrew Schneider
(Guerrilla Games). The first column is the perlin-worley noise generated by remapping
perlin noise with the lowest frequency worley fbm. The next 3 columns are worley fbms
with increasing frequencies, and are used to model the cloud shapes which are rendered
in the last column. See the common tab for all the noise functions used.
*/

// Simple random
float hash(float2 p) {
    return fract(sin(dot(p, float2(127.1, 311.7))) * 43758.5453123);
}

// 2D noise
float noise(float2 p) {
    float2 i = floor(p);
    float2 f = fract(p);
    float a = hash(i);
    float b = hash(i + float2(1.0, 0.0));
    float c = hash(i + float2(0.0, 1.0));
    float d = hash(i + float2(1.0, 1.0));
    float2 u = f*f*(3.0-2.0*f);
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// fBm (fractal brownian motion)
float fbm(float2 p) {
    float total = 0.0;
    float amplitude = 0.5;
    float frequency = 0.0;
    for(int i=0; i<6; i++) {
        total += amplitude * noise(p);
        p *= 2.0;
        amplitude *= 0.5;
    }
    return total;
}

void mainImage(thread float4& fragColor, float2 fragCoord, float iTime, float3 iResolution)
{
    float2 st = fragCoord / iResolution.xy;
    float2 uv = fragCoord / iResolution.y;
    st.x *= 5.; // 5 columns for different noises
    uv -= .02 * iTime;

    float3 col = float3(0.);
    
    float perlinWorley = fbm(uv * 5.0);        

    col += perlinWorley*float3(0.5, 1.0, 0.7);
       
    fragColor = float4(col,1.0);
}