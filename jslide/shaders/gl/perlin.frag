/**
An implementation of tileable 3D Perlin-Worley noise for modeling volumetric clouds
inspired from the chapter Real-Time Volumetric Cloudscapes by Andrew Schneider
(Guerrilla Games). The first column is the perlin-worley noise generated by remapping
perlin noise with the lowest frequency worley fbm. The next 3 columns are worley fbms
with increasing frequencies, and are used to model the cloud shapes which are rendered
in the last column. See the common tab for all the noise functions used.
*/

// Simple random
float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
}

// 2D noise
float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    vec2 u = f*f*(3.0-2.0*f);
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// fBm (fractal brownian motion)
float fbm(vec2 p) {
    float total = 0.0;
    float amplitude = 0.5;
    float frequency = 0.0;
    for(int i=0; i<6; i++) {
        total += amplitude * noise(p);
        p *= 2.0;
        amplitude *= 0.5;
    }
    return total;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 st = fragCoord / iResolution.xy;
    vec2 uv = fragCoord / iResolution.y;
    st.x *= 5.; // 5 columns for different noises
    uv -= .02 * iTime;

    vec3 col = vec3(0.);
    
    float perlinWorley = fbm(uv * 5.0);        

    col += perlinWorley*vec3(0.5, 1.0, 0.7);
       
    fragColor = vec4(col,1.0);
}